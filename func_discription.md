**init_func** — основной контроллер, который активируется при подаче питания. Он инициализирует дочерние модули, управляет цветом светодиода и переводит систему в основной режим работы.

### Алгоритм работы прошивки:

1. **Ввод и подтверждение количества плат**  
   - Ожидание ввода количества задействованных плат через UART в течение 30 секунд.  
   - **Индикация:** светодиод мигает красным.  
   - Считать количество плат (от 1 до 11) и записать его в переменную.  
   - Отправить значение переменной обратно по UART для подтверждения получения.
   - Если за 30 сек не получилось: светодиод загорается красным (10 сек), программа завершается

2. **Режим размещения плат и подачи питания**  
   - Ожидание размещения всех плат, включая контроллерную, на материнской плате и подачи питания.  
   - Ожидание подтверждения по UART (значение "1") в течение 120 секунд.
   - **Индикация:** светодиод мигает жёлтым.
   - После подтверждения светодиод мигнёт жёлтым 3 раза. 

3. **Режим прослушивания RTS**  
   - Система переходит в режим прослушивания RTS на 60 секунд.  
   - **Индикация:** светодиод плавно загорается и гаснет жёлтым цветом.  

4. **Проверка подтверждения**  
   - Если подтверждения получены от всех линий (сравнение с числом в переменной), светодиод загорается зелёным.  
   - В случае отсутствия подтверждения после 60 секунд светодиод загорается красным.

- **child_init** - инициализирующая прошивка для дочерних модулей, которая поднимает линию RTS и отвечает кодом готовности после запроса main контроллера, например: 11111111

- **master_load_test_01** - отправить команды на активацию нагрузочных прошивок с интервалом в 1 сек по очереди на каждую плату. потом раз в несколько секунд выдёргивать логи с каждой платы и выводить в терминал.

- **master_load_test_02** - при отправке в терминал айдишника платы (или порядкового номера в мат.плате) отправляет на конкретную плату сигнал об активации нагрузочной прошивки. Раз в 10 сек запрашивать данные датчиков с аналоговой платы.

- **step_motor_load_test** - шаговики на 25000 (500 мм/с, 50 шагов на мм) рывками по 50 мм со сменой направления. Читать показания с концевиков и писать в лог по изменению.

- **triac_load_test** - в момент времени t0 на 1й плате включаются 2 симистора на 100% и 2 на 50%, если задействована вторая плата - также, после истечения 2х мин - спирали поменять местами (те, которые были на 100%, теперь 50%, те которые 50%, теперь 100%) 

- **sensor_readout** - считывать показания аналоговых датчиков (датчик тока, 2 термопары), поднимать линию RTS, отправлять пакетом собранные данные (логировать раз в 1 сек, посылать раз в 10 сек)

- **analog_load_test** - изменять открытие симисторов от 1% до 100% и обратно в течении 30 секунд, повторить цикл несколько раз

- **digit_load_test** - меандр 50% 500 Гц.

- **dc_motor_load_test** - крутить ДПТ 30 сек в одну сторону, 30 сек в другую, повторить цикл несколько раз

- **qr_reader_func** - прочитать показанный QR код, поднять линию RTS, отправить содержимое QR кода на Master



**master_010**:
отправка команды на смену состояния RTS
- master_init
- master_RTS_changer

**master_011**:
отправка команды на смену состояния RTS + нагрузка
- master_init
- master_RTS_changer
- master_load

**master_012**:
мигает светодиодом, когда очередь доходит до Master-платы
- master_init
- master_blink

**master_013**:
тоже самое, что 012, только + нагрузка

- master_init
- master_blink
- master_load

**master_init** - светодиод на плате мигает после инициализации master-контроллера. (4 пульса по 500мс)

**master_RTS_changer** - контроллер master платы после получения команды от оператора ("s") отправляет команду на все slave платы, чтобы они изменили состояние RTS на противоположное, затем мониторит фронты (восходящие, если линия была опущена и наоборот).

**master_load** - после получения стартового символа разослать по дочерним платам команды на максимальную загрузку в течении 2 мин.

**master_blink** - слушает RS, когда видит сообщение от последней платы - мигает светодиодом и пишет в шину своё сообщение

**slave_010**:
смена состояния RTS через 10 сек (всего 60 сек)
- slave_init
- slave_RTS_updown

**блок прошивок с нагрузкой**:
смена состояния RTS, как в 010 + нагрузка
slave_init+slave_RTS_updown+load
**slave_011_triac_load**
**slave_011_analog_load**
**slave_011_digit_load**
**slave_011_dc_load**
**slave_011_step_load**
**slave_011_QR_load**

**slave_012**:
проверка дочернего RS
- slave_init
- slave_parad

**slave_013**:
slave_012 + нагрузка
**slave_013_triac_load**
**slave_013_analog_load**
**slave_013_digit_load**
**slave_013_dc_load**
**slave_013_step_load**
**slave_013_QR_load**

**slave_init** - светодиод на плате мигает после инициализации slave-контроллера. (4 пульса по 500мс)

**slave_RTS_updown** - контроллер slave платы после инициализации поднимает линию RTS, после ждёт команды на смену состояния линии и раз в 10 секунд меняет его на противоположное. Дублировать поднятое состояние RTS светодиодом на плате. 

**slave_parad** - дочерние по очереди каждая шлёт своё сообщение в шину. Шлёт, когда видит на шине сообщение предыдущей платы
(плата\_2 ждёт сообщение '111', увидела - шлёт '222', ждёт дальше)
управляющая тогглит диод, когда очередь проходит через неё
(т.е. если всё ок, на управляющей диод мерцает с одинаковой частотой)

**slave_triac_load** - открывает симисторы на 25\50\75\100% в цикле 30 секунд. Дважды

**slave_analog_load** - открывает симисторы на 25\50\75\100% в цикле 30 секунд. Дважды

**slave_analog_readout** - читает\логирует\при запросе отправляет по UART показания датчика тока и термопар

